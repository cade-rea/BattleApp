Index: app/src/main/java/com/caderea/battleapp/core/Battle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.caderea.battleapp.core;\r\n\r\nimport com.caderea.battleapp.activity.BattleActivity;\r\nimport com.caderea.battleapp.environment.Environment;\r\nimport com.caderea.battleapp.fighter.EnemyFighter;\r\nimport com.caderea.battleapp.fighter.Fighter;\r\nimport com.caderea.battleapp.queue.QueueAction;\r\n\r\nimport android.os.SystemClock;\r\nimport android.util.Log;\r\n\r\n/**\r\n * Created by Cade on 7/31/2014.\r\n */\r\npublic class Battle implements Runnable {\r\n    private static final int MAGIC_TICK_FACTOR = 5;\r\n    private Fighter fighter1;\r\n    private EnemyFighter fighter2;\r\n    private Environment environment;\r\n    private Clock battleClock;\r\n    private int gameTick;\r\n    private BattleActivity battleActivity;\r\n    private String status;\r\n    private boolean going;\r\n\r\n    private static final String TAG = \"BATTLE\";\r\n\r\n    private static long MILLISECONDS_PER_TICK = 1000;\r\n    private static long SUBTICKS_PER_TICK = 4;\r\n    private static final long TICK_SLEEP_DURATION = MILLISECONDS_PER_TICK / (SUBTICKS_PER_TICK * MAGIC_TICK_FACTOR);\r\n\r\n    public Battle(BattleActivity battleActivity) {\r\n        this.battleActivity = battleActivity;\r\n        status = \"\";\r\n\r\n        fighter1 = loadFighter();\r\n        fighter2 = new EnemyFighter();\r\n\r\n        fighter1.setTarget(fighter2);\r\n        fighter2.setTarget(fighter1);\r\n\r\n        this.battleActivity.setQueues(fighter1.getQueue(), fighter2.getQueue());\r\n\r\n        environment = new Environment();\r\n\r\n        battleClock = new Clock(MILLISECONDS_PER_TICK, SUBTICKS_PER_TICK);\r\n\r\n        going = true;\r\n        gameTick = 0;\r\n    }\r\n\r\n    public void run() {\r\n\r\n        initialize();\r\n\r\n        mainLoop();\r\n\r\n        endBattle();\r\n    }\r\n\r\n    private void initialize() {\r\n        Log.d(TAG,\"running\");\r\n        //set this thread to background priority\r\n        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);\r\n\r\n        //setup user actions\r\n        updateButtons();\r\n\r\n        //start clock\r\n        gameTick = 1;\r\n        Thread clockThread = new Thread(battleClock);\r\n        clockThread.start();\r\n    }\r\n\r\n    private void mainLoop() {\r\n        //main game loop\r\n        Log.d(TAG, \"starting loop\");\r\n        while (going) {\r\n            refreshQueues();\r\n\r\n            if (gameTick < battleClock.getTick()) {\r\n                ++gameTick;\r\n\r\n                doBattleTick();\r\n\r\n            } else {\r\n                doNoTick();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void endBattle() {\r\n        battleClock.stop();\r\n        notifyDone();\r\n    }\r\n\r\n    private void doBattleTick() {\r\n        report(\"Tick:\"+ gameTick + \" \" + fighter1.getName() + \":\" + fighter1.getHealth() + \" :: \" +\r\n                fighter2.getName() + \":\" + fighter2.getHealth());\r\n\r\n        doFighterLoop();\r\n\r\n        botLogic();\r\n    }\r\n\r\n    private void doFighterLoop() {\r\n        Fighter[] fighters = {fighter1, fighter2};\r\n\r\n        for (Fighter fighter: fighters) {\r\n            if (fighter.getHealth() <= 0) {\r\n                report(fighter.getName() + \" has died.\");\r\n                going = false;\r\n                return;\r\n            }\r\n\r\n            if (fighter.getQueue().isNotEmpty()) {\r\n                report(fighter.performNextAction());\r\n            }\r\n        }\r\n    }\r\n\r\n    private void botLogic() {\r\n        //Bot Logic\r\n        if (gameTick % 2 == 0) {\r\n            fighter2.addAttackToQueue();\r\n        }\r\n    }\r\n\r\n    private void doNoTick() {\r\n        //if a tick has not happened\r\n        int st = battleClock.getProgress();\r\n        Log.d(TAG,\"No tick. Subtick:\" + st);\r\n        battleActivity.updateTickProgress(st);\r\n\r\n        SystemClock.sleep(TICK_SLEEP_DURATION);\r\n    }\r\n\r\n    /***\r\n    Screen Reporting\r\n     To call methods in BattleActivity, use:\r\n\r\n     battleActivity.uiHandler.post(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            battleActivity.METHOD_TO_CALL(r);\r\n        }\r\n        });\r\n\r\n\r\n     These methods update the screen by calling corresponding methods in BattleActivity\r\n     */\r\n\r\n\r\n    private void report(final String r) {\r\n        battleActivity.uiHandler.post(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                battleActivity.update(r);\r\n            }\r\n        });\r\n    }\r\n\r\n    private void notifyDone() {\r\n        battleActivity.uiHandler.post(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                battleActivity.notifyDone();\r\n            }\r\n        });\r\n    }\r\n\r\n    private void updateTickProgress(final int progress) {\r\n        battleActivity.uiHandler.post(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                battleActivity.updateTickProgress(progress);\r\n            }\r\n        });\r\n    }\r\n\r\n    private void updateButtons() {\r\n        battleActivity.uiHandler.post(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                battleActivity.updateButtons(fighter1.getActions());\r\n            }\r\n        });\r\n    }\r\n\r\n    public void queueAction(int action) {\r\n        Log.d(TAG,\"queing action\" + action +\"::\" + fighter1.getActions()[action]);\r\n\r\n            if (fighter1.getActions()[action] != null) {\r\n                fighter1.getQueue().offer(new QueueAction(fighter1.getActions()[action]));\r\n            }\r\n    }\r\n\r\n    private void refreshQueues() {\r\n        battleActivity.uiHandler.post(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                battleActivity.refreshQueues();\r\n            }\r\n        });\r\n    }\r\n\r\n    public void stop() {\r\n        going = false;\r\n    }\r\n\r\n    private Fighter loadFighter() {\r\n        return new Fighter();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/caderea/battleapp/core/Battle.java	(revision 0873203d677a65b7d04291cfbca873d49ab58e2f)
+++ app/src/main/java/com/caderea/battleapp/core/Battle.java	(date 1589006405463)
@@ -25,7 +25,7 @@
 
     private static final String TAG = "BATTLE";
 
-    private static long MILLISECONDS_PER_TICK = 1000;
+    private static long MILLISECONDS_PER_TICK = 5000;
     private static long SUBTICKS_PER_TICK = 4;
     private static final long TICK_SLEEP_DURATION = MILLISECONDS_PER_TICK / (SUBTICKS_PER_TICK * MAGIC_TICK_FACTOR);
 
